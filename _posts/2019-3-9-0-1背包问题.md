---
title: 0-1背包问题
key: DP
tags: DP
---

## 求解思路

### 1.确认子问题和状态
　　01背包问题需要求解的就是，为了体积V的背包中物体总价值最大化，件物品中第件应该放入背包中吗？（其中每个物品最多只能放一件） 
<!--more-->
　　为此，我们定义一个二维数组，其中每个元素代表一个状态，即前个物体中若干个放入体积为背包中最大价值。数组为：，其中表示前件中若干个物品放入体积为的背包中的最大价值。 

### 2.初始状态
　　初始状态为和都为0，前者表示前0个物品（也就是空物品）无论装入多大的包中总价值都为0，后者表示体积为0的背包啥价值的物品都装不进去。 


### 3.转移函数
···python
if (背包体积j小于物品i的体积)
    f[i][j] = f[i-1][j] //背包装不下第i个物体，目前只能靠前i-1个物体装包
else
    f[i][j] = max(f[i-1][j], f[i-1][j-Vi] + Wi)
···
　　最后一句的意思就是根据“为了体积V的背包中物体总价值最大化，件物品中第件应该放入背包中吗？”转化而来的。表示第件物体的体积，表示第件物品的价值。这样f[i-1][j]代表的就是不将这件物品放入背包，而f[i-1][j-Vi] + Wi则是代表将第i件放入背包之后的总价值，比较两者的价值，得出最大的价值存入现在的背包之中。

## BP问题的空间优化
   每一次f(i)(j)改变的值只与f(i-1)(x) {x:1...j}有关，f(i-1)(x)是前一次i循环保存下来的值；
　　因此，可以将f缩减成一维数组，从而达到优化空间的目的，状态转移方程转换为 B(j)= max{B(j), B(j-w(i))+v(i)}；
　　并且，状态转移方程，每一次推导V(i)(j)是通过V(i-1)(j-w(i))来推导的，所以一维数组中j的扫描顺序应该从大到小(capacity到0)，否者前一次循环保存下来的值将会被修改，从而造成错误。

　　即，如果后边的依靠前边的修改，那么要从后往前遍历。如果从前向后遍历的话会提前修改后边要用到的前边的值，造成数据在用之前被修改的错误。